Index: src/test/java/org/codehaus/stomp/StompTest.java
===================================================================
--- src/test/java/org/codehaus/stomp/StompTest.java	(revision 90)
+++ src/test/java/org/codehaus/stomp/StompTest.java	(working copy)
@@ -695,7 +695,7 @@
     //-------------------------------------------------------------------------
     protected void setUp() throws Exception {
         connectionFactory = createConnectionFactory();
-        stompConnect = new StompConnect(connectionFactory);
+//        stompConnect = new StompConnect(connectionFactory);
         stompConnect.setUri("tcp://localhost:" + port);
         stompConnect.start();
 
Index: src/test/java/org/codehaus/stomp/ActiveMQStompConnect.java
===================================================================
--- src/test/java/org/codehaus/stomp/ActiveMQStompConnect.java	(revision 90)
+++ src/test/java/org/codehaus/stomp/ActiveMQStompConnect.java	(working copy)
@@ -33,7 +33,7 @@
             if (args.length > 0) {
                 url = args[0];
             }
-            connect.setConnectionFactory(new ActiveMQConnectionFactory(url));
+//            connect.setConnectionFactory(new ActiveMQConnectionFactory(url));
             connect.start();
             connect.join();
         }
Index: src/main/java/org/codehaus/stomp/Stomp.java
===================================================================
--- src/main/java/org/codehaus/stomp/Stomp.java	(revision 90)
+++ src/main/java/org/codehaus/stomp/Stomp.java	(working copy)
@@ -30,6 +30,7 @@
     public static interface Commands {
         String CONNECT = "CONNECT";
         String SEND = "SEND";
+        String RECEIVE = "RECEIVE";
         String DISCONNECT = "DISCONNECT";
         String SUBSCRIBE = "SUB";
         String UNSUBSCRIBE = "UNSUB";
Index: src/main/java/org/codehaus/stomp/tcp/TcpTransport.java
===================================================================
--- src/main/java/org/codehaus/stomp/tcp/TcpTransport.java	(revision 90)
+++ src/main/java/org/codehaus/stomp/tcp/TcpTransport.java	(working copy)
@@ -42,7 +42,7 @@
 import java.util.Map;
 
 /**
- * @version $Revision: $
+ * @version $Revision$
  */
 public class TcpTransport extends ServiceSupport implements Runnable, StompHandler {
     private static final Log log = LogFactory.getLog(TcpTransport.class);
@@ -99,7 +99,9 @@
     /**
      * A one way asynchronous send
      */
-    public void onStompFrame(StompFrame command) throws Exception {
+    // PATCHED BY TOM - THIS CAN BE INVOKED BY THE RECEIPT FOR A SUBSCRIPTION AT THE SAME
+    // TIME AS THE FIRST MESSAGE IS RECEIVED
+    public synchronized void onStompFrame(StompFrame command) throws Exception {
         checkStarted();
         marshaller.marshal(command, dataOut);
         dataOut.flush();
@@ -391,10 +393,10 @@
     }
 
     protected void initializeStreams() throws Exception {
-        TcpBufferedInputStream buffIn = new TcpBufferedInputStream(socket.getInputStream(), ioBufferSize);
-        this.dataIn = new DataInputStream(buffIn);
-        TcpBufferedOutputStream buffOut = new TcpBufferedOutputStream(socket.getOutputStream(), ioBufferSize);
-        this.dataOut = new DataOutputStream(buffOut);
+//        TcpBufferedInputStream buffIn = new TcpBufferedInputStream(socket.getInputStream(), ioBufferSize);
+        this.dataIn = new DataInputStream(socket.getInputStream());//new DataInputStream(buffIn);
+  //      TcpBufferedOutputStream buffOut = new TcpBufferedOutputStream(socket.getOutputStream(), ioBufferSize);
+        this.dataOut = new DataOutputStream(socket.getOutputStream());//new DataOutputStream(buffOut);
     }
 
     protected void closeStreams() throws IOException {
Index: src/main/java/org/codehaus/stomp/jms/StompSession.java
===================================================================
--- src/main/java/org/codehaus/stomp/jms/StompSession.java	(revision 90)
+++ src/main/java/org/codehaus/stomp/jms/StompSession.java	(working copy)
@@ -17,6 +17,8 @@
  */
 package org.codehaus.stomp.jms;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.codehaus.stomp.ProtocolException;
 import org.codehaus.stomp.Stomp;
 import org.codehaus.stomp.StompFrame;
@@ -27,6 +29,8 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.List;
+import java.util.ArrayList;
 
 /**
  * Represents a logical session (a parallel unit of work) within a Stomp connection
@@ -37,7 +41,9 @@
     private final ProtocolConverter protocolConverter;
     private final Session session;
     private MessageProducer producer;
-    private Map<String, Destination> temporaryDestinations = new HashMap<String, Destination>();
+    private static Map<String, Destination> temporaryDestinations = new HashMap<String, Destination>();
+    private List<String> created = new ArrayList<String>();
+    private static final Log log = LogFactory.getLog(StompSession.class);
 
     public StompSession(ProtocolConverter protocolConverter, Session session) {
         this.protocolConverter = protocolConverter;
@@ -61,14 +67,20 @@
 
     public void close() throws JMSException {
         session.close();
+	synchronized (temporaryDestinations) {
+		Iterator<String> i = created.iterator();
+		while (i.hasNext()) {
+			temporaryDestinations.remove(i.next());
+		}
+	}
     }
 
     public void sendToJms(StompFrame command) throws JMSException, ProtocolException {
         Map headers = command.getHeaders();
         String destinationName = (String) headers.remove(Stomp.Headers.Send.DESTINATION);
         Message message = convertFrame(command);
+        Destination destination = convertDestination(destinationName, false);
 
-        Destination destination = convertDestination(destinationName);
 
         int deliveryMode = getDeliveryMode(headers);
         int priority = getPriority(headers);
@@ -78,12 +90,13 @@
     }
 
     public void sendToStomp(Message message, StompSubscription subscription) throws Exception {
+    	log.debug("Sending to stomp");
         StompFrame frame = convertMessage(message);
         frame.getHeaders().put(Stomp.Headers.Message.SUBSCRIPTION, subscription.getSubscriptionId());
         protocolConverter.sendToStomp(frame);
     }
 
-    public Destination convertDestination(String name) throws ProtocolException, JMSException {
+    public Destination convertDestination(String name, boolean forceNew) throws ProtocolException, JMSException {
         if (name == null) {
             throw new ProtocolException("No destination is specified!");
         }
@@ -97,11 +110,22 @@
         }
         else if (name.startsWith("/temp-queue/")) {
             String tempName = name.substring("/temp-queue/".length(), name.length());
-            return temporaryDestination(tempName, session.createTemporaryQueue());
+	    Destination answer = temporaryDestinations.get(tempName);
+
+            if (forceNew || answer == null) {
+	            return temporaryDestination(tempName, session.createTemporaryQueue());
+	    } else {
+		    return answer;
+	    }
         }
         else if (name.startsWith("/temp-topic/")) {
             String tempName = name.substring("/temp-topic/".length(), name.length());
-            return temporaryDestination(tempName, session.createTemporaryTopic());
+            Destination answer = temporaryDestinations.get(tempName);
+            if (forceNew || answer == null) {
+	            return temporaryDestination(tempName, session.createTemporaryTopic());
+	    } else {
+		    return answer;
+	    }
         }
         else {
             throw new ProtocolException("Illegal destination name: [" + name + "] -- StompConnect destinations " +
@@ -118,6 +142,7 @@
             Topic topic = (Topic) d;
             if (d instanceof TemporaryTopic) {
                 buffer.append("/temp-topic/");
+                temporaryDestination(topic.getTopicName(), d);
             }
             else {
                 buffer.append("/topic/");
@@ -128,6 +153,7 @@
             Queue queue = (Queue) d;
             if (d instanceof TemporaryQueue) {
                 buffer.append("/temp-queue/");
+                temporaryDestination(queue.getQueueName(), d);
             }
             else {
                 buffer.append("/queue/");
@@ -139,13 +165,12 @@
 
 
     protected synchronized Destination temporaryDestination(String tempName, Destination temporaryDestination) {
-        Destination answer = temporaryDestinations.get(tempName);
-        if (answer == null) {
-            temporaryDestinations.put(tempName, temporaryDestination);
-            answer = temporaryDestination;
-        }
-        return answer;
-    }
+		synchronized (temporaryDestinations) {
+			temporaryDestinations.put(tempName, temporaryDestination);
+			created.add(tempName);
+		}
+		return temporaryDestination;
+	}
 
     protected int getDeliveryMode(Map headers) throws JMSException {
         Object o = headers.remove(Stomp.Headers.Send.PERSISTENT);
@@ -223,7 +248,7 @@
 
         o = headers.remove(Stomp.Headers.Send.REPLY_TO);
         if (o != null) {
-            msg.setJMSReplyTo(convertDestination((String) o));
+            msg.setJMSReplyTo(convertDestination((String) o, false));
         }
 
         // now the general headers
Index: src/main/java/org/codehaus/stomp/jms/StompSubscription.java
===================================================================
--- src/main/java/org/codehaus/stomp/jms/StompSubscription.java	(revision 90)
+++ src/main/java/org/codehaus/stomp/jms/StompSubscription.java	(working copy)
@@ -53,7 +53,7 @@
         Map headers = frame.getHeaders();
         String selector = (String) headers.remove(Stomp.Headers.Subscribe.SELECTOR);
         String destinationName = (String) headers.get(Stomp.Headers.Subscribe.DESTINATION);
-        destination = session.convertDestination(destinationName);
+        destination = session.convertDestination(destinationName, true);
         Session jmsSession = session.getSession();
         boolean noLocal = false;
 
@@ -82,14 +82,19 @@
     }
 
     public void onMessage(Message message) {
+    	log.debug("onMessage3");
         try {
             int ackMode = session.getSession().getAcknowledgeMode();
-            if (ackMode == Session.CLIENT_ACKNOWLEDGE) {
-                synchronized (this) {
-                    session.getProtocolConverter().addMessageToAck(message);
-                }
-            }
-            session.sendToStomp(message, this);
+			if (ackMode == Session.CLIENT_ACKNOWLEDGE) {
+				synchronized (consumer) {
+					boolean closing = session.getProtocolConverter()
+							.addMessageToAck(message, consumer);
+					if (!closing) {
+						session.sendToStomp(message, this);
+						consumer.wait();
+					}
+				}
+			}
         }
         catch (Exception e) {
             log.error("Failed to process message due to: " + e + ". Message: " + message, e);
Index: src/main/java/org/codehaus/stomp/jms/ProtocolConverter.java
===================================================================
--- src/main/java/org/codehaus/stomp/jms/ProtocolConverter.java	(revision 90)
+++ src/main/java/org/codehaus/stomp/jms/ProtocolConverter.java	(working copy)
@@ -17,6 +17,29 @@
  */
 package org.codehaus.stomp.jms;
 
+import java.io.ByteArrayOutputStream;
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.jms.JMSException;
+import javax.jms.Destination;
+import javax.jms.Message;
+import javax.jms.MessageConsumer;
+import javax.jms.Session;
+import javax.jms.XAConnection;
+import javax.jms.XAConnectionFactory;
+import javax.jms.XASession;
+import javax.naming.InitialContext;
+import javax.transaction.Transaction;
+import javax.transaction.TransactionManager;
+import javax.transaction.xa.XAResource;
+
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.codehaus.stomp.ProtocolException;
@@ -25,21 +48,8 @@
 import org.codehaus.stomp.StompFrameError;
 import org.codehaus.stomp.StompHandler;
 import org.codehaus.stomp.util.IntrospectionSupport;
+import org.jboss.blacktie.tx.JtsTransactionImple;
 
-import javax.jms.Connection;
-import javax.jms.ConnectionFactory;
-import javax.jms.JMSException;
-import javax.jms.Message;
-import javax.jms.Session;
-import java.io.ByteArrayOutputStream;
-import java.io.OutputStreamWriter;
-import java.io.PrintWriter;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Collection;
-import java.util.ArrayList;
-import java.util.concurrent.ConcurrentHashMap;
-
 /**
  * A protocol switch between JMS and Stomp
  *
@@ -48,21 +58,23 @@
  */
 public class ProtocolConverter implements StompHandler {
     private static final transient Log log = LogFactory.getLog(ProtocolConverter.class);
-    private ConnectionFactory connectionFactory;
+    private XAConnectionFactory connectionFactory;
     private final StompHandler outputHandler;
-    private Connection connection;
+    private XAConnection connection;
     private StompSession defaultSession;
     private StompSession clientAckSession;
+    private StompSession xaSession;
     private final Map<String,StompSession> transactedSessions = new ConcurrentHashMap<String,StompSession>();
     private final Map subscriptions = new ConcurrentHashMap();
-    private final Map messages = new ConcurrentHashMap();
+    private final Map<String, MSC> messages = new ConcurrentHashMap<String, MSC>();
+	private boolean closing;
 
-    public ProtocolConverter(ConnectionFactory connectionFactory, StompHandler outputHandler) {
+    public ProtocolConverter(XAConnectionFactory connectionFactory, StompHandler outputHandler) {
         this.connectionFactory = connectionFactory;
         this.outputHandler = outputHandler;
     }
 
-    public ConnectionFactory getConnectionFactory() {
+    public XAConnectionFactory getConnectionFactory() {
         return connectionFactory;
     }
 
@@ -72,6 +84,16 @@
 
     public synchronized void close() throws JMSException {
         try {
+        	closing = true;
+			// PATCHED BY TOM FOR SINGLE MESSAGE DELIVERY
+			Iterator<MSC> iterator = messages.values().iterator();
+			while (iterator.hasNext()) {
+				MSC msc = iterator.next();
+				synchronized (msc.consumer) {
+					msc.consumer.setMessageListener(null);
+					msc.consumer.notify();
+				}
+			}
             // lets close all the sessions first
             JMSException firstException = null;
             Collection<StompSession> sessions = new ArrayList<StompSession>(transactedSessions.values());
@@ -81,6 +103,10 @@
             if (clientAckSession != null) {
                 sessions.add(clientAckSession);
             }
+            if (xaSession != null) {
+            	sessions.add(xaSession);
+            }
+
             for (StompSession session : sessions) {
                 try {
                     if (log.isDebugEnabled()) {
@@ -108,6 +134,7 @@
             connection = null;
             defaultSession = null;
             clientAckSession = null;
+            xaSession = null;
             transactedSessions.clear();
             subscriptions.clear();
             messages.clear();
@@ -131,6 +158,9 @@
             if (action.startsWith(Stomp.Commands.SEND)) {
                 onStompSend(command);
             }
+            else if (action.startsWith(Stomp.Commands.RECEIVE)) {
+                onStompReceive(command);
+            }
             else if (action.startsWith(Stomp.Commands.ACK)) {
                 onStompAck(command);
             }
@@ -185,11 +215,18 @@
     public void onException(Exception e) {
         log.error("Caught: " + e, e);
     }
+    
+	public boolean addMessageToAck(Message message, MessageConsumer consumer)
+			throws JMSException {
+		if (!closing) {
+			MSC ms = new MSC();
+			ms.message = message;
+			ms.consumer = consumer;
+			messages.put(message.getJMSMessageID(), ms);
+		}
+		return closing;
+	}
 
-    public void addMessageToAck(Message message) throws JMSException {
-        messages.put(message.getJMSMessageID(), message);
-    }
-
     // Implemenation methods
     //-------------------------------------------------------------------------
     protected void onStompConnect(StompFrame command) throws Exception {
@@ -202,14 +239,14 @@
         String passcode = (String) headers.get(Stomp.Headers.Connect.PASSCODE);
         String clientId = (String) headers.get(Stomp.Headers.Connect.CLIENT_ID);
 
-        ConnectionFactory factory = getConnectionFactory();
+        XAConnectionFactory factory = getConnectionFactory();
         IntrospectionSupport.setProperties(factory, headers, "factory.");
 
         if (login != null) {
-            connection = factory.createConnection(login, passcode);
+            connection = factory.createXAConnection(login, passcode);
         }
         else {
-            connection = factory.createConnection();
+            connection = factory.createXAConnection();
         }
         if (clientId != null) {
             connection.setClientID(clientId);
@@ -243,24 +280,120 @@
         close();
     }
 
-    protected void onStompSend(StompFrame command) throws Exception {
-        checkConnected();
+	protected void onStompSend(StompFrame command) throws Exception {
+		checkConnected();
 
-        Map headers = command.getHeaders();
-        String stompTx = (String) headers.get(Stomp.Headers.TRANSACTION);
+		Map headers = command.getHeaders();
 
-        StompSession session;
-        if (stompTx != null) {
-            session = getExistingTransactedSession(stompTx);
-        }
-        else {
-            session = getDefaultSession();
-        }
+		String xid = (String) headers.get("messagexid");
 
-        session.sendToJms(command);
-        sendResponse(command);
-    }
+		if (xid != null) {
+			log.trace("Transaction was propagated: " + xid);
+			JtsTransactionImple.resume(xid);
+			log.trace("Resumed transaction");
 
+			javax.transaction.TransactionManager txMgr = (TransactionManager) new InitialContext()
+					.lookup("java:/TransactionManager");
+			StompSession session = getXASession();
+
+			XAResource xaRes = ((XASession)session.getSession()).getXAResource();
+			Transaction transaction = txMgr.getTransaction();
+			log.trace("Got transaction: " + transaction);
+			transaction.enlistResource(xaRes);
+			log.trace("Enlisted resource");
+			
+			session.sendToJms(command);
+			
+			transaction.delistResource(xaRes, XAResource.TMSUCCESS);
+			
+			log.trace("Delisted resource");
+			JtsTransactionImple.suspend();
+			log.trace("Suspended transaction");
+		} else {
+			log.trace("WAS NULL XID");
+
+			String stompTx = (String) headers.get(Stomp.Headers.TRANSACTION);
+
+			StompSession session;
+			if (stompTx != null) {
+				session = getExistingTransactedSession(stompTx);
+			} else {
+				session = getDefaultSession();
+			}
+
+			session.sendToJms(command);
+			log.trace("Sent to JMS");
+		}
+		sendResponse(command);
+		log.trace("Sent Response");
+	}
+
+	protected void onStompReceive(StompFrame command) throws Exception {
+		checkConnected();
+
+		Map headers = command.getHeaders();
+		String destinationName = (String) headers.remove(Stomp.Headers.Send.DESTINATION);
+		String ior = (String) headers.get("messagexid");
+		StompSession session = getSession(headers, ior != null);
+		Object o = headers.remove(Stomp.Headers.Send.EXPIRATION_TIME);
+		long ttl = (o != null ? Long.parseLong((String) o) : session.getProducer().getTimeToLive());
+		Destination destination = session.convertDestination(destinationName, true);
+		Message msg;
+        MessageConsumer consumer;
+
+		log.trace("Consuming message - ttl=" + ttl + " IOR=" + ior);
+
+		if (ior != null) {
+			TransactionManager txMgr = (TransactionManager) new InitialContext()
+				.lookup("java:/TransactionManager");
+
+			// resume the transaction
+			JtsTransactionImple.resume(ior);
+
+			// create an XA consumer
+			XASession xaSession = (XASession) session.getSession();
+			XAResource xaRes = xaSession.getXAResource();
+			consumer = xaSession.createConsumer(destination);
+
+			// make sure the message is transactionally consumed:
+			Transaction transaction = txMgr.getTransaction();
+			transaction.enlistResource(xaRes);
+			msg = (ttl > 0 ? consumer.receive(ttl) : consumer.receive());
+			transaction.delistResource(xaRes, XAResource.TMSUSPEND);
+			JtsTransactionImple.suspend();
+		} else {
+			javax.jms.Session ss = session.getSession();
+			consumer = ss.createConsumer(destination);
+			msg = (ttl > 0 ? consumer.receive(ttl) : consumer.receive());
+		}
+
+		log.trace("Consumed message: " + msg);
+        consumer.close();
+
+		StompFrame sf;
+
+		if (msg == null) {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            PrintWriter stream = new PrintWriter(new OutputStreamWriter(baos, "UTF-8"));
+			stream.print("No messages available");
+            stream.close();
+
+            HashMap eheaders = new HashMap();
+            eheaders.put(Stomp.Headers.Error.MESSAGE, "timeout");
+
+            sf = new StompFrame(Stomp.Responses.ERROR, eheaders, baos.toByteArray());
+		} else {
+			// Don't use sendResponse since it uses Stomp.Responses.RECEIPT as the action
+			// which only allows zero length message bodies, Stomp.Responses.MESSAGE is correct:
+			sf = session.convertMessage(msg);
+		}
+
+		if (headers.containsKey(Stomp.Headers.RECEIPT_REQUESTED))
+			sf.getHeaders().put(Stomp.Headers.Response.RECEIPT_ID, headers.get(Stomp.Headers.RECEIPT_REQUESTED));
+
+		sendToStomp(sf);
+	}
+
     protected void onStompBegin(StompFrame command) throws Exception {
         checkConnected();
 
@@ -324,6 +457,7 @@
         }
         else {
             String ackMode = (String) headers.get(Stomp.Headers.Subscribe.ACK_MODE);
+
             if (ackMode != null && Stomp.Headers.Subscribe.AckModeValues.CLIENT.equals(ackMode)) {
                 session = getClientAckSession();
             }
@@ -343,6 +477,7 @@
         }
         subscription = new StompSubscription(session, subscriptionId, command);
         subscriptions.put(subscriptionId, subscription);
+
         sendResponse(command);
     }
 
@@ -379,14 +514,20 @@
         String messageId = (String) headers.get(Stomp.Headers.Ack.MESSAGE_ID);
         if (messageId == null) {
             throw new ProtocolException("ACK received without a message-id to acknowledge!");
-        }
+		}
 
-        Message message = (Message) messages.remove(messageId);
-        if (message == null) {
-            throw new ProtocolException("No such message for message-id: " + messageId);
-        }
-        message.acknowledge();
-        sendResponse(command);
+		MSC ms = (MSC) messages.remove(messageId);
+		if (ms == null) {
+			throw new ProtocolException("No such message for message-id: "
+					+ messageId);
+		}
+
+		// PATCHED BY TOM FOR SINGLE MESSAGE DELIVERY
+		synchronized (ms.consumer) {
+			ms.message.acknowledge();
+			ms.consumer.notify();
+		}
+		sendResponse(command);
     }
 
     protected void checkConnected() throws ProtocolException {
@@ -416,6 +557,37 @@
         return clientAckSession;
     }
 
+	protected StompSession getXASession() throws JMSException {
+		if (xaSession == null) {
+			Session session = connection.createXASession();
+			if (log.isDebugEnabled()) {
+				log.debug("Created XA session");
+			}
+			xaSession = new StompSession(this, session);
+			log.trace("Created XA Session");
+		} else {
+			log.trace("Returned existing XA session");
+		}
+		return xaSession;
+	}    
+
+	protected StompSession getSession(Map headers, boolean isXA) throws JMSException, ProtocolException {
+		if (isXA) {
+			if (xaSession == null) {
+				xaSession = new StompSession(this, connection.createXASession());
+				log.trace("Created XA Session");
+			} else {
+				log.trace("Returned existing XA session");
+			}
+
+			return xaSession;
+		} else {
+			String stompTx = (String) headers.get(Stomp.Headers.TRANSACTION);
+
+			return (stompTx == null ? getDefaultSession() : getExistingTransactedSession(stompTx));
+		}
+	}
+
     /**
      * Returns the transacted session for the given ID or throws an exception if there is no such session
      */
@@ -473,4 +645,10 @@
      */
     protected void considerClosingTransactedSession(StompSession session, String stompTx) {
     }
+    
+	private class MSC {
+		public Message message;
+		public Session session;
+		public MessageConsumer consumer;
+	}
 }
Index: src/main/java/org/codehaus/stomp/jms/StompConnect.java
===================================================================
--- src/main/java/org/codehaus/stomp/jms/StompConnect.java	(revision 90)
+++ src/main/java/org/codehaus/stomp/jms/StompConnect.java	(working copy)
@@ -17,22 +17,24 @@
  */
 package org.codehaus.stomp.jms;
 
-import org.codehaus.stomp.StompHandler;
-import org.codehaus.stomp.StompHandlerFactory;
-import org.codehaus.stomp.tcp.TcpTransportServer;
-import org.codehaus.stomp.util.ServiceSupport;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.Hashtable;
 
 import javax.jms.ConnectionFactory;
+import javax.jms.XAConnectionFactory;
 import javax.naming.InitialContext;
 import javax.naming.NamingException;
 import javax.net.ServerSocketFactory;
-import java.io.IOException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.Hashtable;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.codehaus.stomp.StompHandler;
+import org.codehaus.stomp.StompHandlerFactory;
+import org.codehaus.stomp.tcp.TcpTransportServer;
+import org.codehaus.stomp.util.ServiceSupport;
+
 /**
  * This class represents a service which accepts STOMP socket connections and binds them to JMS operations
  *
@@ -41,7 +43,7 @@
 public class StompConnect extends ServiceSupport implements StompHandlerFactory {
     private static final transient Log log = LogFactory.getLog(StompConnect.class);
 
-    private ConnectionFactory connectionFactory;
+    private XAConnectionFactory connectionFactory;
     private String uri = "tcp://localhost:61613";
     private URI location;
     private ServerSocketFactory serverSocketFactory;
@@ -53,12 +55,12 @@
     public StompConnect() {
     }
 
-    public StompConnect(ConnectionFactory connectionFactory) {
+    public StompConnect(XAConnectionFactory connectionFactory) {
         this.connectionFactory = connectionFactory;
     }
 
     public StompHandler createStompHandler(StompHandler outputHandler) throws NamingException {
-        ConnectionFactory factory = getConnectionFactory();
+        XAConnectionFactory factory = getConnectionFactory();
         if (factory == null) {
             throw new IllegalArgumentException("No ConnectionFactory is configured!");
         }
@@ -74,7 +76,7 @@
 
     // Properties
     //-------------------------------------------------------------------------
-    public ConnectionFactory getConnectionFactory() throws NamingException {
+    public XAConnectionFactory getConnectionFactory() throws NamingException {
         if (connectionFactory == null) {
             connectionFactory = createConnectionFactory();
         }
@@ -84,7 +86,7 @@
     /**
      * Sets the JMS connection factory to use to communicate with
      */
-    public void setConnectionFactory(ConnectionFactory connectionFactory) {
+    public void setConnectionFactory(XAConnectionFactory connectionFactory) {
         this.connectionFactory = connectionFactory;
     }
 
@@ -181,7 +183,7 @@
     // Implementation methods
     //-------------------------------------------------------------------------
     protected void doStart() throws Exception {
-        ConnectionFactory factory = getConnectionFactory();
+        XAConnectionFactory factory = getConnectionFactory();
         if (factory == null) {
             throw new IllegalArgumentException("No ConnectionFactory has been configured!");
         }
@@ -201,7 +203,7 @@
      * Factory method to lazily create a {@link ConnectionFactory} if one is not explicitly configured.
      * By default lets try looking in JNDI
      */
-    protected ConnectionFactory createConnectionFactory() throws NamingException {
+    protected XAConnectionFactory createConnectionFactory() throws NamingException {
         String name = getJndiName();
         log.info("Looking up name: " + name + " in JNDI InitialContext for JMS ConnectionFactory");
 
@@ -209,8 +211,8 @@
         if (value == null) {
             throw new IllegalArgumentException("No ConnectionFactory object is available in JNDI at name: " + name);
         }
-        if (value instanceof ConnectionFactory) {
-            return (ConnectionFactory) value;
+        if (value instanceof XAConnectionFactory) {
+            return (XAConnectionFactory) value;
         }
         else {
             throw new IllegalArgumentException("The object in JNDI at name: " + name
Index: pom.xml
===================================================================
--- pom.xml	(revision 90)
+++ pom.xml	(working copy)
@@ -3,8 +3,14 @@
   <groupId>org.codehaus.stomp</groupId>
   <artifactId>stompconnect</artifactId>
   <packaging>jar</packaging>
-  <version>1.0</version>
-
+  <version>1.0.3-BT</version>
+  
+  <developers>
+	<developer>
+		<id>one</id>
+      		<name>one</name>
+	</developer>
+  </developers>	
   <name>StompConnect</name>
   <description>
     StompConnect allows any Message Orientated Middleware (MOM)
@@ -33,6 +39,50 @@
   </scm>
 
   <dependencies>
+  		<!-- Transactions START -->
+		<dependency>
+			<groupId>org.jboss.javaee</groupId>
+			<artifactId>jboss-javaee</artifactId>
+			<scope>provided</scope>
+		<version>5.0.1.GA</version>
+		</dependency>
+		<dependency>
+			<groupId>jboss.jbossts</groupId>
+			<artifactId>jbossjts</artifactId>
+			<scope>provided</scope>
+		<version>4.6.1.GA</version>
+		</dependency>
+		<dependency>
+			<groupId>jboss.jbossts</groupId>
+			<artifactId>jbossjts-jacorb</artifactId>
+			<scope>provided</scope>
+		<version>4.6.1.GA</version>
+		</dependency>
+		<!-- Transactions END -->
+  		<dependency>
+			<groupId>log4j</groupId>
+			<artifactId>log4j</artifactId>
+			<version>1.2.15</version>
+			<exclusions>
+				<exclusion>
+					<groupId>com.sun.jmx</groupId>
+					<artifactId>jmxri</artifactId>
+				</exclusion>
+				<exclusion>
+					<groupId>com.sun.jdmk</groupId>
+					<artifactId>jmxtools</artifactId>
+				</exclusion>
+				<exclusion>
+					<groupId>javax.jms</groupId>
+					<artifactId>jms</artifactId>
+				</exclusion>
+				<exclusion>
+					<groupId>javax.mail</groupId>
+					<artifactId>mail</artifactId>
+				</exclusion>
+			</exclusions>
+		</dependency>
+  
     <dependency>
       <groupId>commons-logging</groupId>
       <artifactId>commons-logging</artifactId>
@@ -88,19 +138,15 @@
 
   <distributionManagement>
     <repository>
-      <id>codehaus.org</id>
-      <name>Stomp Central Repository</name>
-      <url>dav:https://dav.codehaus.org/repository/stomp/</url>
+      <id>jboss-releases-repository</id>
+      <name>JBoss Releases Repository</name>
+      <url>https://repository.jboss.org/nexus/service/local/staging/deploy/maven2/</url>
     </repository>
     <snapshotRepository>
-      <id>codehaus.org</id>
-      <name>Stomp Central Development Repository</name>
-      <url>dav:https://dav.codehaus.org/snapshots.repository/stomp/</url>
+      <id>jboss-snapshots-repository</id>
+      <name>JBoss Snapshots Repository</name>
+      <url>https://repository.jboss.org/nexus/content/repositories/snapshots/</url>
     </snapshotRepository>
-    <site>
-      <id>codehaus.org</id>
-      <url>dav:https://dav.codehaus.org/stomp/maven/</url>
-    </site>
   </distributionManagement>
 
   <reporting>
@@ -122,6 +168,11 @@
     </extensions>
 
     <plugins>
+ <plugin>
+ <!-- Entry needed to create, install and deploy sources jars -->
+ <groupId>org.apache.maven.plugins</groupId>
+ <artifactId>maven-source-plugin</artifactId>
+ </plugin>
       <plugin>
         <artifactId>maven-release-plugin</artifactId>
         <configuration>
